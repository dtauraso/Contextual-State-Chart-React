import { Children } from "react";
import { State, StatesObject } from "../App.types";
// f(stateTree) => names and states arrays
const insertName = (names: any, name: string[], stateId: Number): any => {
  // console.log({ names, name, stateId });
  // save trie node as a state
  // extra strings are added to the end of the state name if there is a match

  if (name.length === 0) {
    // console.log("base case");
    if ("id" in names) {
      const sortedKeysNoId = Object.keys(names)
        .filter((key) => key !== "id")
        .sort();
      // console.log({ sortedKeysNoId });
      if (sortedKeysNoId.length === 0) {
        return {
          tree: {
            ...names,
            "!": { id: stateId },
          },
          updatedName: ["!"],
        };
      }
      const lastKey = sortedKeysNoId[sortedKeysNoId.length - 1];
      const lastKeyCharCode = lastKey.charCodeAt(0);
      const nextKeyCharCode = lastKeyCharCode + 1;
      const nextKey = String.fromCharCode(nextKeyCharCode);
      // console.log({ lastKey, lastKeyCharCode, nextKey });

      if (nextKeyCharCode < 126) {
        return {
          tree: {
            ...names,
            [nextKey]: { id: stateId },
          },
          updatedName: [nextKey],
        };
      } else {
        // traversing the tree of autogenerated context names case
        const { tree, updatedName } = insertName(names[lastKey], [], stateId);

        return {
          tree: {
            ...names,
            [lastKey]: tree,
          },
          updatedName: [lastKey, ...updatedName],
        };
      }
    }
    return {
      tree: {
        ...names,
        id: stateId,
      },
      updatedName: [],
    };
  } else if (Object.keys(names).length === 0) {
    const { tree, updatedName } = insertName(
      {},
      name.slice(1, name.length),
      stateId
    );
    return {
      tree: {
        ...names,
        [name[0]]: tree,
      },
      updatedName: [name[0], ...updatedName],
    };
  } else if (name[0] in names) {
    // console.log("first name is in names");
    const { tree, updatedName } = insertName(
      names[name[0]],
      name.slice(1, name.length),
      stateId
    );
    return {
      tree: {
        ...names,
        [name[0]]: tree,
      },
      updatedName: [name[0], ...updatedName],
    };
  } else {
    // console.log("no name is in names");
    // console.log({ x });
    // build up trie
    const { tree, updatedName } = insertName(
      {},
      name.slice(1, name.length),
      stateId
    );
    return {
      tree: {
        ...names,
        [name[0]]: tree,
      },
      updatedName: [name[0], ...updatedName],
    };
  }
};
const setAttribute = (object: any, newObject: any, key: string, value: any) => {
  if (key in object) {
    newObject[key] = value;
  }
};

const getSubStatePaths = (
  node: any,
  paths: string[][],
  currentPath: string[]
) => {
  // console.log({ node });
  if (typeof node === "string") {
    return;
  }
  const keys = Object.keys(node);
  const filteredKeys = keys.filter(
    (key) =>
      !["functionCode", "start", "next", "children", "variables"].includes(key)
  );
  if (filteredKeys.length === 0) {
    paths.push(currentPath);
  } else {
    // console.log({ filteredKeys, keys });
    filteredKeys.forEach((stateNamePart: string) => {
      // console.log({ stateNamePart, node });
      getSubStatePaths(node[stateNamePart], paths, [
        ...currentPath,
        stateNamePart,
      ]);
    });
  }
};

const addState = (
  statesObject: any,
  stateTree: any,
  stateName: any,
  children: string[][],
  variables: any,
  isVariable: boolean
) => {
  statesObject.maxStateId += 1;
  let newState: State = {};
  newState["A_name"] = stateName;

  if (!isVariable) {
    newState["set2SFromStateFunctionCallCount"] = 0;
    newState["stateRunCount"] = 0;
  }
  setAttribute(stateTree, newState, "functionCode", stateTree?.functionCode);
  setAttribute(stateTree, newState, "next", stateTree?.next);
  setAttribute(stateTree, newState, "start", stateTree?.start);
  setAttribute(stateTree, newState, "value", stateTree?.value);
  setAttribute(stateTree, newState, "children", children);
  setAttribute(stateTree, newState, "variables", variables);

  statesObject.states[statesObject.maxStateId] = newState;
  statesObject.states[statesObject.maxStateId]["id"] = statesObject.maxStateId;
};
const specialPrint = (object: any) => {
  // console.log({ object });
  console.log(JSON.parse(JSON.stringify(object)));
};
const getStateNames = (
  stateTree: any,
  stateName: any,
  names: any,
  statesObject: any,
  stateNameToStateIdAndVarCount: any
) => {
  // console.log({ stateName, stateTree });
  const keys = Object.keys(stateTree);
  // const keyMapsToObject = keys.find(
  //   (key) =>
  //     Object.prototype.toString.call(stateTree[key]) === "[object Object]"
  // );
  /*
  if any of the below keys is inside stateTree
    we have reached a stop conditin
  */
  let foundStop = false;
  const stopKeys = ["functionCode", "start", "next", "children", "variables"];
  stopKeys.forEach((stopKey) => {
    if (stopKey in stateTree) {
      foundStop = true;
    }
  });
  if (foundStop) {
    // console.log("at stop condition");
    // stop conditions for the full state name
    if ("children" in stateTree || "variables" in stateTree) {
      // console.log("at stop condition");
      // add state
      // collect data for state
      // names.push(stateName);
      // addState(statesObject, stateTree, stateName);
      // console.log("statesObject", JSON.parse(JSON.stringify(statesObject)));
      let variableData: any = {};
      if ("variables" in stateTree) {
        // variable states are added here
        // save variable names and id's for state
        Object.keys(stateTree.variables).forEach((variableName) => {
          names.push([variableName]);
          addState(
            statesObject,
            stateTree.variables[variableName],
            [variableName],
            [],
            {},
            true
          );
          const variableId = statesObject.maxStateId;
          variableData[variableName] = variableId;
        });
      }
      let childrenPaths: string[][] = [];

      if ("children" in stateTree) {
        // add state names from children into state's children list
        getSubStatePaths(stateTree.children, childrenPaths, []);
      }
      // add state here
      // console.log("variableData", JSON.parse(JSON.stringify(variableData)));
      // console.log("paths", JSON.parse(JSON.stringify(childrenPaths)));
      names.push(stateName);
      addState(
        statesObject,
        stateTree,
        stateName,
        childrenPaths,
        variableData,
        false
      );
      if ("children" in stateTree) {
        Object.keys(stateTree.children).forEach((child) => {
          getStateNames(
            stateTree.children[child],
            [child],
            names,
            statesObject,
            stateNameToStateIdAndVarCount
          );
        });
      }
    } else if (!("variables" in stateTree) && !("children" in stateTree)) {
      names.push(stateName);
      addState(statesObject, stateTree, stateName, [], {}, false);
    }
  }

  // continue down the state name path
  const filteredKeys = keys.filter(
    (key) =>
      !["functionCode", "start", "next", "children", "variables"].includes(key)
  );
  if (filteredKeys.length > 0) {
    filteredKeys.forEach((key) => {
      // getStateNames(key)
      getStateNames(
        stateTree[key],
        [...stateName, key],
        names,
        statesObject,
        stateNameToStateIdAndVarCount
      );
    });
  }
  /*
    if keys has any context names
      getStateNames(each context name)
    */
  // if (keys.includes("value")) {
  //   names.push(stateName);
  //   addState(statesObject, stateTree, stateName);
  //   return statesObject.maxStateId;
  // }
  // if (keys.includes("children")) {
  //   // stateTree is an internal node
  //   names.push(stateName);
  //   addState(statesObject, stateTree, stateName);
  //   if (keys.includes("variables")) {
  //     stateNameToStateIdAndVarCount[stateName.join(" ")] = {
  //       varCountDown: Object.keys(stateTree.variables).length,
  //       stateId: names.length - 1,
  //     };
  //   }
  //   Object.keys(stateTree.children).forEach((key) => {
  //     getStateNames(
  //       stateTree.children[key],
  //       [key],
  //       names,
  //       statesObject,
  //       stateNameToStateIdAndVarCount
  //     );
  //   });
  // }
  // if (keys.includes("variables")) {
  //   if (stateName.length > 0) {
  //     // the current name is also done
  //     names.push(stateName);
  //     addState(statesObject, stateTree, stateName);
  //     // stateNameToStateIdAndVarCount[stateName.join(" ")] = {
  //     //   varCountDown: Object.keys(stateTree.variables).length,
  //     //   stateId: names.length - 1,
  //     // };
  //   }
  //   const filteredKeys = keys.filter(
  //     (key) =>
  //       ![
  //         "functionCode",
  //         "functionName",
  //         "start",
  //         "next",
  //         "children",
  //         "variables",
  //       ].includes(key)
  //   );
  //   if (filteredKeys.length > 0) {
  //     // there are more names to try
  //     console.log({ filteredKeys });
  //     filteredKeys.forEach((key) => {
  //       console.log({ key, stateTree });
  //       getStateNames(
  //         stateTree[key],
  //         [...stateName, key],
  //         names,
  //         statesObject,
  //         stateNameToStateIdAndVarCount
  //       );
  //     });
  //   }
  //   Object.keys(stateTree.variables).forEach((key) => {
  //     const variableId = getStateNames(
  //       stateTree.variables[key],
  //       [key],
  //       names,
  //       statesObject,
  //       stateNameToStateIdAndVarCount
  //     );
  //     // how to link the variable's id value in the object with it's name as a key
  //     // in the state's variable's object
  //     // how to find the id of the state
  //     // variables have to added locally
  //     // O(h) where h is the height of the tree from the stateName to the leaf node
  //     // stateName.join(" ") -> {varCountDown, id} when it's been added and has variables
  //     // console.log({ variableId });
  //     // console.log({ stateName: stateName.join(" ") });
  //     // console.log({
  //     //   variableId,
  //     //   stateName: stateName,
  //     //   stuff: stateNameToStateIdAndVarCount[stateName.join(" ")],
  //     // });
  //     const stateNameString = stateName.join(" ");
  //     if (stateNameString in stateNameToStateIdAndVarCount) {
  //       if ("stateId" in stateNameToStateIdAndVarCount[stateNameString]) {
  //         const stateId =
  //           stateNameToStateIdAndVarCount[stateNameString].stateId;
  //         statesObject.states[stateId].variables[key] = variableId;
  //         stateNameToStateIdAndVarCount[stateNameString].varCountDown -= 1;
  //         if (
  //           stateNameToStateIdAndVarCount[stateNameString].varCountDown === 0
  //         ) {
  //           delete stateNameToStateIdAndVarCount[stateNameString];
  //         }
  //       }
  //     }
  //   });
  // } else if (keyMapsToObject === undefined) {
  //   // no key maps to an object
  //   // stateTree is a leaf node
  //   names.push(stateName);
  //   addState(statesObject, stateTree, stateName);
  // } else if (
  //   !keys.includes("function") &&
  //   !keys.includes("next") &&
  //   !keys.includes("start") &&
  //   !keys.includes("children")
  // ) {
  //   // stateTree is part of a state name

  //   keys.forEach((key) => {
  //     getStateNames(
  //       stateTree[key],
  //       [...stateName, key],
  //       names,
  //       statesObject,
  //       stateNameToStateIdAndVarCount
  //     );
  //   });
  // }
};
const makeArrays = (stateTree: any) => {
  // get the state names
  let names: string[][] = [];
  // needs to be {} for O(1) adding, updating, and deleting
  let statesObject: StatesObject = { maxStateId: -1, states: {} };
  getStateNames(stateTree, [], names, statesObject, {});
  console.log({ names, states: statesObject.states });
  // console.log({ keys: Object.keys(names) });
  let namesTrie: any = {};
  names.forEach((nameArray: any, i: Number) => {
    const { tree, updatedName } = insertName(namesTrie, nameArray, i);
    // console.log({ updatedName });
    // console.log({ tree, updatedName });
    namesTrie = tree;
  });
  console.log({ namesTrie, statesObject });
  return { namesTrie, statesObject };
};
/*
state object -> stateId
childrenNames -> all paths from current state to the children keys

*/

/*
rules of states
each state must be able to access any other state in O(n); where n is the length of the path through
the trie tree
the user must be able to access each node in the context tree of each state
each state that has variables, can be n words but must have a unique path between all variables
the states has. this lets the user use the first word only to refer to it in code.
each state has children
a state cannot have variables but no children
variable names inside the state scope
  not allowed
  a
    b
      d
    c
  ----------
  allowed
  a
   b
    d
  c

role of variables
primitives
small data structures(js inbuilt data structures)
  hash table
  arrays, multidimential arrays
  adjaciency list
accessing a variable name takes O(p), where p is the number of name parts
root state for the search tries(26 tries)
    root
        search
            26 roots(a-z)
        random
            26 pivot states(a-z) for each trie
                branch pivot states for each unique path in the trie
    root/random/userLetter/a-z/[0, n]; for each branch pivot state
        each branch pivot state is orgainized by letter
    root/random/userLetter/a/[0, n]; all the nodes in the search

    c/{randomNumber/, ....}/title -> [title/{randomNumber/, ....}, ]
*/

export { insertName, setAttribute, getStateNames, makeArrays };
